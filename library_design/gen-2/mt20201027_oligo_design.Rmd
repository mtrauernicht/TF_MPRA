---
title: "Oligo Design - TF reporter screen gen 2"
author: "Max Trauernicht"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output: 
  prettydoc::html_pretty:
    theme: leonids
  #   highlight: github
  #   toc: true
  #   toc_float: true
  #   code_folding: show
  # editor_options:
  #   chunk_output_type: console
---

*knitr document van Steensel lab*

# Oligo Design - TF reporter screen gen 2

## Introduction
In this document, an oligo library of TF reporters will be generated. These oligos contain TF binding sites of ~30 selected TFs, random inactive spacing between them, followed by minimal promoters, and a barcode in the transcription unit.

```{r setup, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8) 
# libraries:
library(ggplot2)
library(seqinr)
library(seqLogo)
library(universalmotif)
library(Biostrings)
library(SimRAD)
library(gtools)
library(DNABarcodes)
library(phylotools)
library(ape)
library(magrittr)
library(dplyr)
library(readr)
library(stringr)
library(tidyr)
library(heatmaply)
library(pheatmap)
library(tibble)
library(ggseqlogo)
library(RColorBrewer)
library(data.table)
library(vwr)
library(ggbeeswarm)
library(ggrepel)
library(sjmisc)
library(RcmdrMisc)
library(LncFinder)
library(ENCODExplorer)
library(biomaRt)
library(ggpubr)
```



```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE, message=FALSE}
SetFileName <- function(filename, initials) {
  # Set filename with extension and initials to make filename with date integrated.
  filename <- substitute(filename)
  initials <- substitute(initials)
  filename <- paste0(initials, Date, filename)
  filename
}

# Function to substring the right part of the motif
substrRight <- function(x, n){
  substr(x, nchar(x)-n+1, nchar(x))
}


# Function to load PWM matrix
get_pwm_feature_matrix <- function(motif_meta_fn, fimo_fn, db = 2) {

  # validate args
  valid_dbs <- 1:2
  if(!db %in% valid_dbs)
    stop('Invalid db (database version). Please use db=1 (maintained for backward compatibility only) or db=2')

  # db=1 is maintained for backward compatibility only
  if(db == 1) {

    # read in motif metadata
    motif_meta    <- read.csv(motif_meta_fn)

    # check whether motif metadata contain essential annotations
    if(!all(c('PWM.ID', 'Cognate.TF') %in% colnames(motif_meta))) {
      message('The motif metadata file does not contain the essential columns PWM.ID and Cognate.TF')
    }

    motif_minimal <- motif_meta[, c('PWM.ID', 'Cognate.TF')]

    # load fimo output --> extract motif id, sequence id and p-value
    df <- read.table(fimo_fn)
    df <- df[, c(1, 2, 7)]

    colnames(df) <- c('PWM.ID', 'seqid', 'pval')

    # add TF id
    df <- merge(df, motif_minimal, by = 'PWM.ID')

    # group motif hits by sequence id
    l <- split(df, df[['seqid']])

    # multiple PWM and multiple hits possible. Reduce hits to one per TF, keeping best p-val only
    l <- lapply(l, function(x) {
      x_by_tf <- split(x, x[['Cognate.TF']], drop = TRUE)
      x_by_tf <- lapply(x_by_tf, function(y) y[which.min(y$pval), ])
      do.call('rbind', x_by_tf)
    })

    # initialize feature matrix
    n_tf          <- motif_minimal[['Cognate.TF']] %>%
      unique %>%
      length
    n_seq         <- length(l)
    pwm           <- matrix(1, nrow = n_seq, ncol = n_tf)
    colnames(pwm) <- (motif_minimal[['Cognate.TF']] %>% unique)

    # replace :: from names of composite motifs
    colnames(pwm) <- str_replace_all(colnames(pwm), '::', '_')

    # fill in feature matrix
    for(i in 1 : n_seq) {
      pwm[i, l[[i]][['Cognate.TF']]] <- l[[i]]$pval
    }

    # -log10 transform
    pwm           <- -1 * log10(pwm)

    # coerce to tib and return
    tib_fimo <- as_data_frame(pwm) %>%
      mutate(id = names(l))
      dplyr::select(id, everything())

  }

  # db = 2 (default)
  else {

    # load metadata
    tib_meta    <- read_csv(motif_meta_fn) %>%
      # extract tf symbol from motif id (Cognate_TF unsafe, it can be empty) and replace :: occurrences
      mutate(tf_symbol = str_remove(ID, '_[0-9]*'),
             tf_symbol = str_replace(tf_symbol, '::', '_')) %>%
      dplyr::select(motif_id = `PWM ID`, tf_symbol)

    # load fimo results
    tib_fimo <- read_tsv(fimo_fn) %>%
      # extract motif id, sequence id and p-value
      dplyr::select(motif_id, sequence_name, pval = `p-value`, start)

    # add tf symbol to fimo results
    tib_fimo <- tib_fimo %>%
      left_join(tib_meta, by = 'motif_id') %>%
      # remove hits with missing motif id (composite pwms)
      filter(!is.na(tf_symbol))

    # # select best hit for each motif and sequence
    # tib_fimo <- tib_fimo %>%
    #   group_by(sequence_name, tf_symbol) %>%
    #   dplyr::slice(which.min(pval)) %>%
    #   ungroup()

    # spread into feature matrix
    tib_fimo <- tib_fimo %>%
      mutate(pval = -1 * log10(pval)) %>%
      dplyr::select(-motif_id) %>%
      spread(key = tf_symbol, value = pval, fill = 0, drop = TRUE) %>%
      # perform cosmetics on the id
      mutate(id = sequence_name) %>%
      dplyr::select(-c(sequence_name)) %>%
      dplyr::select(id, everything())

  }

  return(tib_fimo)

}

ReadFasta<-function(file) {
   # Read the file line by line
   fasta<-readLines(file)
   # Identify header lines
   ind<-grep(">", fasta)
   # Identify the sequence lines
   s<-data.frame(ind=ind, from=ind+1, to=c((ind-1)[-1], length(fasta)))
   # Process sequence lines
   seqs<-rep(NA, length(ind))
   for(i in 1:length(ind)) {
      seqs[i]<-paste(fasta[s$from[i]:s$to[i]], collapse="")
   }
   # Create a data frame 
   DF<-data.frame(name=gsub(">", "", fasta[ind]), sequence=seqs)
   # Return the data frame as a result object from the function
   return(DF)
}
```


## Analysis

### Motif filtering and characterization
```{r out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE, message=FALSE}
# Load Lambert et al. cluster information
tf_clusters <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/lambert_tf_clusters.csv", header = T)

# Select only SELEX data 
tf_clusters <- tf_clusters[tf_clusters$Motif.Type == "HT-SELEX",]

# Select one motif per TF - Remove duplicate motifs (select newest motif)
tf_clusters$year <- gsub(".*([0-9]{4})", "\\1", tf_clusters$Motif.Source)
tf_clusters$TF <- gsub("(.*?)_.*", "\\1", tf_clusters$Motif.ID)
tf_clusters$TF <- gsub("V\\$","", tf_clusters$TF)
tf_clusters <- unique(setDT(tf_clusters)[order(TF, -year)], by = "TF")

# Count cluster occurrences within the same family
tf_clusters$count <- ave(tf_clusters$Cluster.., tf_clusters$Cluster.., tf_clusters$TF.Family, FUN = function(x) length(x))


cluster_counts <- tf_clusters %>% dplyr::select(TF.Family, Cluster.., count) %>% unique()
cluster_counts$total_count <- ave(cluster_counts$count, cluster_counts$TF.Family, FUN = function(x) sum(x))
cluster_counts$motif_count <- ave(cluster_counts$Cluster.., cluster_counts$TF.Family, FUN = function(x) length(unique(x)))

# Plot cluster occurrence distribution
ggplot(cluster_counts, aes(y = count, x = "All TFs", label = TF.Family)) +
  geom_quasirandom(color = ifelse(cluster_counts$count <= 8, "black", "red")) +
  ylab("TF motifs per cluster") +
  xlab("") +
  geom_hline(yintercept = 8, linetype = "dashed", color = "red") +
  # geom_text(aes(0.7,7,label = "motif overlap cutoff", vjust = 0.5), size = 4) +
  geom_text_repel(data = subset(cluster_counts, count > 8),
                  segment.color = "black",
                  direction = "x") +
  theme_pubr(border = T)



# Plot number of distinct motifs vs. number of clusters
plot_ly(data=cluster_counts %>% dplyr::select(TF.Family, total_count, motif_count) %>% 
          unique(), 
        x = ~reorder(TF.Family,-total_count), 
        y = ~total_count, type = 'bar', name = 'Distinct motifs',
        marker = list(color = "#2D3047")) %>%
    add_trace(y = ~motif_count, name = 'Distinct motif clusters',
              marker = list(color = "#FF9B71")) %>%
    layout(yaxis = list(title = 'Count'), barmode = 'group') %>%
  layout(xaxis = list(title = "TF family"),
         yaxis = list(title = "Distinct motifs"),
         title = "All TFs - Motif cluster counts vs. motif counts")

ggplot(cluster_counts) +
  geom_quasirandom(aes(x = reorder(TF.Family,-total_count), y = count), 
             color = ifelse(cluster_counts$count <= 8, "grey50", "red"))+ 
  theme_bw() +
  geom_hline(yintercept = 8, linetype = "dashed", color = "red") +
  geom_text(aes(30,8,label = "motif overlap cutoff", vjust = -0.5), size = 4)+
  ylab("TF motifs per cluster") +
  xlab("TF family") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) 

tf_clusters$count <- as.numeric(tf_clusters$count)
tfs_selected <- tf_clusters[tf_clusters$count <= 8,]

# Manually remove all irrelevant zinc-finger TFs - re-check this if needed
znf <- c("ZNF", "BCL", "CG31670", "DPF1", "HIC", "HINFP1", "OSR", "OVOL", "PRDM", "SNAI", "ZBTB", "ZSCAN")
tfs_selected <- tfs_selected[!grep(paste(znf, collapse = "|"), tfs_selected$TF),]


# Manually curated TF-list
tf_candidates <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/tf_candidate_list.csv", header = T) 
tfs_removed <- tfs_selected[!tfs_selected$TF %in% tf_candidates$TF, ]
tfs_selected_filt <- tfs_selected[tfs_selected$TF %in% tf_candidates$TF, ]

tfs_selected_filt$total_count <- ave(tfs_selected_filt$TF.Family, tfs_selected_filt$TF.Family,FUN = function(x) length(x))
tfs_selected_filt$motif_count <- ave(tfs_selected_filt$Cluster.., tfs_selected_filt$TF.Family, FUN = function(x) length(unique(x)))
tfs_selected_filt$total_count <- as.numeric(tfs_selected_filt$total_count)


clusters_sel <- tfs_selected_filt %>% dplyr::select(TF.Family, Cluster..)
cluster_counts$cluster_id <- paste(cluster_counts$TF.Family, cluster_counts$Cluster.., sep = "_")
clusters_sel$cluster_id <- paste(clusters_sel$TF.Family, clusters_sel$Cluster.., sep = "_")
clusters_sel_df <- cluster_counts[cluster_counts$cluster_id %in% clusters_sel$cluster_id,]
clusters_sel_df$total_count <- ave(clusters_sel_df$count, clusters_sel_df$TF.Family, FUN = function(x) sum(x))
clusters_sel_df$motif_count <- ave(clusters_sel_df$Cluster.., clusters_sel_df$TF.Family, FUN = function(x) length(unique(x)))

plot_ly(data=clusters_sel_df %>% dplyr::select(TF.Family, total_count, motif_count) %>% 
          unique(), 
        x = ~reorder(TF.Family,-total_count), 
        y = ~total_count, type = 'bar', name = 'Total TFs in selected clusters',
        marker = list(color = "#2D3047")) %>%
    add_trace(y = ~motif_count, name = 'Selected TFs',
              marker = list(color = "#FF9B71")) %>%
    layout(yaxis = list(title = 'Count'), barmode = 'group') %>%
  layout(xaxis = list(title = "TF family"),
         yaxis = list(title = "Distinct motifs"),
         title = "Chosen TFs - Motif cluster counts vs. motif counts")

```

### Visualize motifs
```{r}
# Final selection TFs
# Add selected composite motifs
composite_motifs <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/composite_motifs.csv", header = T)
# Add AHR & JUN because they're interesting (but not unique - keep this in mind)
special_motifs <- data.frame(TF = c("AHR:ARNT", "FOS::JUN", "FOXA1", "FOXO1"),
                             motif_id = c("MA0006.1.jaspar","MA0099.3.jaspar", "M09569_1.94d.txt", "M05738_1.94d.txt"))
tfs_selected_filt <- tfs_selected_filt %>% dplyr::select(TF, CIS.BP.ID) %>%
  setnames(c("TF", "motif_id")) %>%
  mutate(motif_id = paste(motif_id, ".txt", sep = "")) %>%
  rbind(composite_motifs) %>%
  rbind(special_motifs)

# tfs_selected_filt <- read_csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/HumanTFs_Lambert_curated.csv") %>%
#   filter(best_motif == "TRUE") %>%
#   mutate(motif_id = paste(`CIS-BP_ID`, ".txt", sep = "")) %>%
#   mutate(TF = gsub("(.*?)_.*", "\\1", motif_ID)) %>%
#   mutate(TF = gsub("V\\$","", TF)) %>%
#   distinct(TF, motif_id)

# Visualize all motifs
seq_logos <- list()
for(i in 1:nrow(tfs_selected_filt)) {
  x <- tfs_selected_filt$motif_id[i]
  if (str_contains(x, "txt") == TRUE) {
    pwm <- read.table(paste("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/PWMs/",
                            tfs_selected_filt$motif_id[i], sep = ""), header = T) %>% dplyr::select(-Pos) %>% t()
    seq_logos[i] <- list(pwm)
  }
  if (str_contains(x, "pcm") == TRUE)  {
    pwm <- read.table(paste("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/PWMs/",
                       tfs_selected_filt$motif_id[i], sep = ""), header = F) %>% column_to_rownames("V1")
    pwm <- as.matrix(pwm)
  seq_logos[i] <- list(pwm)
  }
    if (str_contains(x, "jaspar") == TRUE) {
    pwm <- read_jaspar(paste("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/PWMs/",
                       tfs_selected_filt$motif_id[i], sep = ""))
    pwm <- pwm@motif
    # Transform to relative values
    pwm <- colPercents(pwm)/100
    pwm <- pwm[1:4,]
  seq_logos[i] <- list(pwm)
  }
}


## Rename the titles of the pwms
names(seq_logos) <- tfs_selected_filt$TF

# Create sequence plot of all pwms
ggseqlogo(seq_logos, ncol = 8, scales = "free") + theme_bw()+ theme(strip.background =element_rect(fill="#E6A08A"))
```

## Motif similarity clusters
```{r}
## Import chosen motifs
motifs_selected <- tfs_selected_filt %>%
  mutate(motif_id = gsub(".txt", "", motif_id))

## Plot 1: Show from which clusters I selected the motifs
tf_clusters <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/lambert_tf_clusters.csv", header = T)
tf_clusters$year <- gsub(".*([0-9]{4})", "\\1", tf_clusters$Motif.Source)
tf_clusters$TF <- gsub("(.*?)_.*", "\\1", tf_clusters$Motif.ID)
tf_clusters$TF <- gsub("V\\$","", tf_clusters$TF)
tf_clusters <- unique(setDT(tf_clusters)[order(TF, -year)], by = "TF")
tf_clusters$count <- as.numeric(ave(tf_clusters$Cluster.., tf_clusters$Cluster.., FUN = function(x) length(x)))
tf_clusters$TF[tf_clusters$TF == "04-Oct"] <- "POU5F1"
tf_clusters$TF[tf_clusters$TF == "TCF4"] <- "TCF7L2"
tf_clusters$TF[tf_clusters$TF == "NR1H4"] <- "NR1H4::RXRA"
tf_clusters$TF[tf_clusters$TF == "NR4A2"] <- "NR4A2::RXRA"
tf_clusters$TF[tf_clusters$TF == "PPARG"] <- "PPARG::RXRA"
tf_clusters$TF[tf_clusters$TF == "PPARA"] <- "PPARA::RXRA"
tf_clusters$TF[tf_clusters$TF == "PPARA"] <- "PPARA::RXRA"
tf_clusters$TF[tf_clusters$TF == "VDR"] <- "VDR::RXRA"

tf_clusters_mat <- tf_clusters %>%
  dplyr::select(TF) %>%
  distinct()

tf_clusters_mat2 <- tf_clusters_mat %>%
  dplyr::select("TF2" = TF)

tf_clusters_mat <- expand_grid(tf_clusters_mat, tf_clusters_mat2)

clusters <- tf_clusters %>%
  dplyr::select("cluster" = `Cluster..`, TF)

clusters2 <- tf_clusters %>%
  dplyr::select("cluster2" = `Cluster..`, "TF2" = TF)

tfs_chosen <- read_csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/gcf6578_gen2_stimulation-2/mt20211021_bc_annotation_combined.csv") %>%
  distinct(tf) %>%
  filter(str_detect(tf, "neg|minP|hBGm|mCMV|andom|promega|TF-seq|romanov|hPGK|RANDOM", neg = T))

tf_clusters_mat <- tf_clusters_mat %>%
  left_join(clusters) %>%
  left_join(clusters2) %>%
  mutate(same_cluster = ifelse(cluster == cluster2, 1, 0)) %>%
  distinct(TF, TF2, same_cluster) 

tf_clusters_mat2 <- tf_clusters_mat %>%
  spread(key = "TF2", value = "same_cluster") %>%
  column_to_rownames("TF") %>%
  as.matrix()

ord <- hclust( dist(tf_clusters_mat2, method = "manhattan"), method = "ward.D" )$order

tf_clusters_mat <- tf_clusters_mat %>%
  mutate(TF = factor(TF, levels = rownames(tf_clusters_mat2)[ord]),
         TF2 = factor(TF2, levels = rownames(tf_clusters_mat2)[ord])) %>%
  mutate(same_cluster = ifelse(same_cluster == 1, "Yes", "No")) %>%
  mutate(same_cluster = ifelse(TF == TF2 & TF %in% tfs_chosen$tf, "Chosen", same_cluster))

ggplot(tf_clusters_mat,
       aes(x = TF, y = TF2, fill = same_cluster)) +
  geom_tile_rast() +
  scale_fill_manual(values = c("Yes" = "grey90", "No" = "white", "Chosen" = "red")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position = "none")

## Plot 2: Show the similarity between the chosen TFBSs
motif_similarity <- read_csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/MotifSimMatrix_Lambert_2018.csv")

motif_similarity <- motif_similarity[,-1404] 

motif_similarity_df <- motif_similarity %>%
  pivot_longer(cols = - '...1', names_to = "motif2", values_to = "similarity") %>%
  dplyr::select("motif1" = `...1`, motif2, similarity) %>%
  mutate(similarity = as.numeric(similarity)) 

motif_similarity_df_selected <- motif_similarity_df %>%
  filter(motif1 %in% motifs_selected$motif_id & motif2 %in% motifs_selected$motif_id) %>%
  replace(is.na(.), 0)

motif_similarity_mat <- motif_similarity_df_selected %>%
  spread(key = "motif2", value = "similarity") %>%
  column_to_rownames("motif1")

ord <- hclust( dist(motif_similarity_mat, method = "manhattan"), method = "ward.D" )$order

motif_similarity_df_selected <- motif_similarity_df_selected %>%
  mutate(motif1 = factor(motif1, levels = rownames(motif_similarity_mat)[ord]),
         motif2 = factor(motif2, levels = rownames(motif_similarity_mat)[ord]))

ggplot(motif_similarity_df_selected,
       aes(x = motif1, y = motif2, fill = similarity)) +
  geom_tile_rast() +
  scale_fill_gradient2(low = "#2a9d8f", mid = "white", high = "#e76f51")

```


### Create DNA barcodes
This code was used to create unique 13-bp barcodes that do not overlap previously chosen (pMT02) barcodes.
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE, message=FALSE}
# # Create barcodes with length = 13
# barc <- create.dnabarcodes(n = 13, dist = 3, filter.triplets = T,
#                            filter.gc = T, filter.self_complementary = T, cores = 24)

# write.csv2(barc, file = "/DATA/usr/m.trauernicht/projects/tf_activity_reporter/data/SuRE_TF_1/TF-reporter_library_design/parameter_files/barcodes.csv")
# barc <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/barc-13.csv", row.names = 1)
# colnames(barc) <- "barcode"
# 
# # Filter out ATGs
# barc <- barc[-grep("ATG",barc$barcode),]
# 
# # Filter out EcoRI & NheI sites
# ecori_nhei <- c("GAATTC","GCTAGC")
# barc <- barc[-grep(paste(ecori_nhei, collapse = "|"),barc)]
# 
# # Filter out barcodes that are similar to the pMT02 barcodes
# ref_seq <- ReadFasta("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/mt20191205_oligo_pool.fasta")
# 
# # Remove adapters from reference sequence (cause these are not in the sequencing data)
# ref_seq$sequence <- gsub("CGGAGCGAACCGAGTTAG", "", ref_seq$sequence)
# ref_seq$sequence <- gsub("CATCGTCGCATCCAAGAG", "", ref_seq$sequence)
# 
# 
# ## the barcode should be the last 12 bases of the sequence
# ref_seq$barcode <- gsub(".*([A-Z]{12})$", "\\1", ref_seq$sequence)
# ref_bc <- ref_seq$barcode
# 
# # For each barcode in the deisgn, calculate the levenshtein distance to each non-matched barcode
# n <- 0
# for (i in 1:46643) {
#   if (i == 1) {
#     l <- data.frame(levenshtein.distance(barc[i], ref_bc))
#   }
#   else {
#     l[i] <- levenshtein.distance(barc[i], ref_bc)
# 
#     # Keep track of the progress
#     n <- n + length(i)
#     percent <- (n / 46643)*100
#     progress <- paste("progress:", percent, "%")
#     if (percent %% 10 == 0) {
#     print(progress)
#     }
#   }
# 
# }
# names(l) <- barc
# 
# # Discard sequences that have a levenshtein distance of 3 or more to one or more pMT02 barcodes
# lev <- l
# lev2 <- lev[,!colSums(lev <= 2) >= 1]
# barc_keep <- colnames(lev2)
# write.csv(barc_keep, "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/parameter_files/barc_selected.csv")
```


### Generate motifs from energy logos
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE, message=FALSE}
# Write out motifs of chosen TFs
seq <- data.frame("motif" = "")
for (i in 1:length(seq_logos)){
  seq_log <- t(data.frame(seq_logos[i]))
  seq[i,] <- paste(colnames(seq_log)[max.col(seq_log,ties.method="first")], collapse = "")
}
tf_motifs <- data.frame("TF" = names(seq_logos),
                        "motif" = seq)

# Compute GC-content of selected motifs
tf_motifs_fasta <- tf_motifs %>% setnames(c("seq.name", "seq.text"))
dat2fasta(tf_motifs, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/gen-2_tf-motifs.fasta") 
tf_motifs_fasta <- seqinr::read.fasta("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/gen-2_tf-motifs.fasta")
gc <- compute_GC(tf_motifs_fasta)

# Plot gc distribution
density <- density(gc$GC.content)

plot_ly(x = ~density$x, y = ~density$y, type = 'scatter', mode = 'lines', fill = 'tozeroy') %>% 
  layout(xaxis = list(title = 'GC content'),
         yaxis = list(title = 'Density'))
```

### Uniqueness of chosen TFs vs all TFs?
```{r out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE, message=FALSE}
tf_selected <- tf_motifs %>%
  mutate(seq.name = gsub("::.*", "", seq.name),
         seq.name = gsub(":.*", "", seq.name)) %>%
  setnames("seq.name","TF") %>%
  dplyr::select(TF) %>%
  mutate(design = "yes")
tf_selected$TF[tf_selected$TF == "RAR"] <- "RARA"
tf_unique <- merge(tf_clusters, tf_selected, all = T)
tf_unique$design[is.na(tf_unique$design)] <- "no"
tf_unique <- tf_unique[!is.na(tf_unique$TF.Family),]
tf_unique <- tf_unique[-grep("^FO", tf_unique$TF),]

ggplot(tf_unique, aes(x = design, y = count,)) +
  geom_quasirandom(color =  "#2D3047") +
  geom_boxplot(alpha = 0.4) +
  xlab("chosen?")+
  ylab("#TFs in motif cluster")+
  theme_bw()
```



### Which cell lines express unique TFs?
```{r out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE, message=FALSE}
# Search for data on encode and download it
# x <- queryEncode(assay = ".*RNA-seq",
#                     biosample_name = "A549", fixed = FALSE,
#                  file_accession = "ENCFF627QMV")
# downloadEncode(x)

# # Load RNA-seq data from different cell lines
# hepg2_rna <- read_tsv("/DATA/usr/m.trauernicht/data/RNA_seq/HepG2/ENCFF649AHO.tsv") %>%
#   dplyr::select(gene_id, FPKM) %>%
#   filter(grepl("ENSG", gene_id)) %>%
#   mutate(gene_id = gsub(".[0-9]+$", "", gene_id))
# load('/DATA/usr/m.martinez.ara/GitLab/gurten/gurten/data/fc181121_epsure_tadec_rnaseq_expr_joshi.RData')
# mES_rna <- tib_fpkm_joshi %>% dplyr::select(symbol, twoi_1)
# K562_rna <- read_tsv("/DATA/usr/m.trauernicht/data/RNA_seq/K562/ENCFF201HGA.tsv") %>%
#   dplyr::select(gene_id, FPKM) %>%
#   filter(grepl("ENSG", gene_id)) %>%
#   mutate(gene_id = gsub(".[0-9]+$", "", gene_id))
# MCF7_rna <- read_tsv("/DATA/usr/m.trauernicht/data/RNA_seq/MCF-7/ENCFF009GDJ.tsv") %>%
#   dplyr::select(gene_id, FPKM) %>%
#   filter(grepl("ENSG", gene_id)) %>%
#   mutate(gene_id = gsub(".[0-9]+$", "", gene_id))
# A549_rna <- read_tsv("/DATA/usr/m.trauernicht/data/RNA_seq/A549/ENCFF627QMV.tsv") %>%
#   dplyr::select(gene_id, FPKM) %>%
#   filter(grepl("ENSG", gene_id)) %>%
#   mutate(gene_id = gsub(".[0-9]+$", "", gene_id))

# # Annotate RNA-seq data
# ensembl <- useMart("ensembl")
# mart <- useDataset("hsapiens_gene_ensembl", mart = ensembl)
# genes <- hepg2_rna$gene_id
# G_list <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id","hgnc_symbol"),values=genes,mart= mart)
# hepg2_rna <- merge(hepg2_rna,G_list,by.x="gene_id",by.y="ensembl_gene_id")
# 
# # Extract interesting HepG2 genes
# top_genes <- read.csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/top100pubmedGenes.csv")
# hepg2_top_genes <- hepg2_rna[hepg2_rna$FPKM >= 10,]
# hepg2_top_genes <- hepg2_top_genes[hepg2_top_genes$hgnc_symbol %in% top_genes$SYMBOL,]
# 
# genes <- K562_rna$gene_id
# G_list <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id","hgnc_symbol"),values=genes,mart= mart)
# K562_rna <- merge(K562_rna,G_list,by.x="gene_id",by.y="ensembl_gene_id")
# 
# genes <- MCF7_rna$gene_id
# G_list <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id","hgnc_symbol"),values=genes,mart= mart)
# MCF7_rna <- merge(MCF7_rna,G_list,by.x="gene_id",by.y="ensembl_gene_id")
# 
# genes <- A549_rna$gene_id
# G_list <- getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id","hgnc_symbol"),values=genes,mart= mart)
# A549_rna <- merge(A549_rna,G_list,by.x="gene_id",by.y="ensembl_gene_id")
# 
# Only keep TFs (with SELEX-seq motif)
# hepg2_rna <- hepg2_rna %>%
#   setnames("FPKM", "HepG2") %>%
#   filter(hepg2_rna$hgnc_symbol %in% tfs_selected$TF)
# K562_rna <- K562_rna %>%
#   setnames("FPKM", "K562") %>%
#   filter(K562_rna$hgnc_symbol %in% tfs_selected$TF)
# mES_rna <- mES_rna %>%
#   setnames(c("symbol", "twoi_1"), c("hgnc_symbol", "mES")) %>%
#   filter(mES_rna$hgnc_symbol %in% tfs_selected$TF)
# MCF7_rna <- MCF7_rna %>%
#   setnames("FPKM", "MCF-7") %>%
#   filter(MCF7_rna$hgnc_symbol %in% tfs_selected$TF)
# A549_rna <- A549_rna %>%
#   setnames("FPKM", "A549") %>%
#   filter(A549_rna$hgnc_symbol %in% tfs_selected$TF)

# Load in previously created RNA-seq data
load('/DATA/usr/m.martinez.ara/GitLab/gurten/gurten/data/fc181121_epsure_tadec_rnaseq_expr_joshi.RData')
mES_rna <- tib_fpkm_joshi %>% dplyr::select(symbol, twoi_1)
mES_rna <- mES_rna %>%
  setnames(c("symbol", "twoi_1"), c("hgnc_symbol", "mES")) %>%
  filter(mES_rna$hgnc_symbol %in% tfs_selected$TF)
load("/DATA/usr/m.trauernicht/data/RNA_seq/HepG2/hepg2_rna.Rdata")
load("/DATA/usr/m.trauernicht/data/RNA_seq/K562/K562_rna.Rdata")
load("/DATA/usr/m.trauernicht/data/RNA_seq/A549/A549_rna.Rdata")
load("/DATA/usr/m.trauernicht/data/RNA_seq/MCF-7/MCF7_rna.Rdata")

# Combine all data frames and add motif counts
tf_rna <- Reduce(function(x,y) merge(x,y,all=T), list(hepg2_rna, K562_rna, mES_rna, MCF7_rna, A549_rna))
tf_rna <- melt(tf_rna, id.vars = c("hgnc_symbol", "gene_id"), variable.name = "cell_type", value.name = "FPKM")
tf_rna[is.na(tf_rna)] <- 0
tf_rna <- merge(tfs_selected %>% dplyr::select(TF, count), tf_rna, by.x="TF",by.y="hgnc_symbol", all = T)
tf_rna$cell_type <- as.character(tf_rna$cell_type)


# Annotate categories
tf_rna$unique <- "Yes"
tf_rna$unique[is.na(tf_rna$count)] <- "No"
tf_rna$expressed <- "High"
tf_rna$expressed[tf_rna$FPKM < 10] <- "Low"
tf_rna <- na.omit(tf_rna)

# Plot distribution of unique TF expression per cell type
ggplot(tf_rna[tf_rna$unique == "Yes",], aes(color=cell_type, x = cell_type, y=FPKM, alpha = 0.4)) +
  geom_quasirandom() + theme_bw() +
  scale_color_brewer(palette = "Set2")+
  labs(title = "Expression of TFs with unique motifs per cell type")+
  ylim(0,50) + geom_hline(yintercept = 10, linetype = "dashed")

# Plot number of unique TFs with more than 10 FPKM (high expression cutoff)
for (i in unique(tf_rna$cell_type)) {
  for (j in unique(tf_rna$unique)) {
    for (k in unique(tf_rna$expressed)) {
      tf_rna$n_tfs[tf_rna$cell_type == i & tf_rna$unique == j & tf_rna$expressed == k] <-
        nrow(tf_rna[tf_rna$cell_type == i & tf_rna$unique == j & tf_rna$expressed == k,])
    }
  }
}
tf_rna$percentage <- ave(tf_rna$count, tf_rna$cell_type, FUN = function(x) x/sum(x))
tf_rna <- na.omit(tf_rna)

ggplot(tf_rna[tf_rna$unique == "Yes" & tf_rna$expressed == "High",] %>% dplyr::select(n_tfs, cell_type) %>% unique(),
       aes(x = reorder(cell_type, -n_tfs), y = n_tfs, fill = cell_type)) +
  geom_bar(stat = "identity") + theme_bw() +
  xlab("Cell type") +
  ylab("Number of expressed TFs with unique motifs") +
  scale_fill_brewer(palette = "Set2")

tf_selected <- tf_motifs %>%
  mutate(seq.name = gsub("::.*", "", seq.name),
         seq.name = gsub(":.*", "", seq.name)) %>%
  setnames("seq.name","TF") %>%
  dplyr::select(TF) %>%
  mutate(design = "yes")

tf_rna <- merge(tf_rna, tf_selected, all =T)
tf_rna$design[is.na(tf_rna$design)] <- "no"

ggplot(tf_rna[!is.na(tf_rna$cell_type),], aes(y = FPKM, x = design, color = design, alpha = 0.4)) +
  geom_boxplot()+
  geom_quasirandom() +
  labs(title = "TF expression per cell type", subtitle = "All interesting candidate TFs vs. unique candidate TFs")+
  scale_color_brewer(palette = "Set2") +
  theme_bw() +
  #geom_hline(yintercept = 10, linetype = "dashed", color = "red") +
  ylim(0,100) +
  facet_wrap(~cell_type, nrow = 1)


ggplot(tf_rna[!is.na(tf_rna$cell_type) & tf_rna$design == "yes",], aes(y = FPKM, x = "TF", color = cell_type, alpha = 0.4)) +
  geom_point() +
  labs(title = "TF expression per TF")+
  scale_color_brewer(palette = "Set2") +
  theme_bw() +
  geom_hline(yintercept = 10, linetype = "dashed", color = "red") +
  ylim(0,100) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1.0, vjust = 0)) +
  facet_wrap(~TF)

tfs_hepg2 <- tf_rna$TF[tf_rna$cell_type == "HepG2" & tf_rna$expressed == "High" & tf_rna$unique == "Yes"]
tfs_hepg2 <- na.omit(tfs_hepg2)
```




### Add negative controls motifs
These are motifs of the selected TFs with 2-4 essential nucleotides mutated to another base
```{r out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE, message=FALSE}
tf.df <- tf_motifs %>% setnames(c("TF", "motif"))

# Add mutated controls - this is done manually by just mutating core bases in the motif based on the energy logos
tf.df.neg <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018/TF_negative_controls.csv") %>%
  dplyr::select(-motif) %>%
  mutate(TF = paste(TF, "neg", sep = "_")) %>%
  setnames(c("TF", "motif"))

tf.df <- rbind(tf.df, tf.df.neg)
```



### Check motif abundance of chosen motifs and negative controls 
```{r out.width= "80%", fig.align= "center", echo = FALSE, warning = FALSE, message=FALSE}
motif_check <- tf.df 
setnames(motif_check, c("seq.name", "seq.text"))

# Write fasta file to run on FIMO script
# dat2fasta(motif_check, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/motif_check.fasta") 
```


### Run FIMO script
```{bash run fimo db2_4, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/motif_check
# query=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/motif_check.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 2 --o $odir $motfn $query
```

### Load FIMO results
```{r build tf motif matrices db2: 5bp_spacer, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_motif_check  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/motif_check/fimo.tsv',
                                        db            = 2)

tib_pwm_motif_check  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/reporter_check/fimo.tsv',
                                        db            = 2)

tib_pwm_motif_check$ctrl <- "No"
tib_pwm_motif_check$ctrl[grep("neg", tib_pwm_motif_check$id)] <- "Yes"

neg_ctrl <- tib_pwm_motif_check[tib_pwm_motif_check$ctrl == "Yes",]
neg_ctrl <- neg_ctrl %>% column_to_rownames("id")
neg_ctrl <- neg_ctrl[, -(which(colSums(neg_ctrl %>% dplyr::select(, -ctrl)) ==0))]
heatmaply(as.matrix(neg_ctrl %>% dplyr::select(-ctrl)))
```
*It looks like the negative control bind relatively few important TFs - they should be able to serve as negative controls*


### Adding dimensions to the DF - sequences will be added in later stages
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Create whole df by merging all conditions
# Import parameters
spacings <- data.frame("spacing" = c("5bp", "10bp"))
distances <- data.frame("distance" = c("10bp", "21bp"))
promoters <- data.frame("promoter" = c("minP", "mCMV"))
barcodes <- data.frame("n_barcode" = 1:5)
background <- data.frame("background" = 1:3)
tf.df <- tf.df %>% setnames(c("TF", "motif"))
tf.df <- Reduce(function(x, y) merge(x, y, all=TRUE), list(tf.df, spacings, distances,
                                                            barcodes, promoters, background))

# Adding the DNA sequence from 5' to 3'

## Constant 5' primer sequence
tf.df$primer1_seq <- ""

## Add motif placings and spacings between them
tf.df$motif1 <- tf.df$motif
tf.df$space1 <- ""
tf.df$motif2 <- tf.df$motif
tf.df$space2 <- ""
tf.df$motif3 <- tf.df$motif
tf.df$space3 <- ""
tf.df$motif4 <- tf.df$motif
  
# Sequence from last TF-motif to start of minimal promoter
tf.df$distance_seq <- ""

## Minimal promoter
tf.df$promoter_sequence <- "TAGAGGGTATATAATGGAAGCTCGACTTCCAG"
tf.df$promoter_sequence[tf.df$promoter == "mCMV"] <- "GGCGTTTACTATGGGAGGTCTATATAAGCAGAGCTCGTTTAGTGAACCGTCAGATC"

## S1 Illumina adapter
tf.df$S1_primer <- "CACGACGCTCTTCCGATCT"

## Barcode
tf.df$barcode <- ""

## 3' Primer sequence
tf.df$primer2_seq <- ""
```


### Add random sequence promoter for some conditions
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Add random 32 bp promoter
rd.promoter <- tf.df
rd.promoter <- rd.promoter[rd.promoter$spacing == "10bp" & rd.promoter$distance == "21bp" & 
                             rd.promoter$background == 1 & rd.promoter$promoter == "minP",]
rd.promoter$promoter <- "Random"
rd.promoter$promoter_sequence <- "GGTTAGCGATCCAATTCAGCTAGATTTTAAGC" # Sequence generated in first library
tf.df <- rbind(tf.df, rd.promoter)
```


### Add optimal 5' primer sequence - I checked that the previously used sequence still has no TF binding
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Generate 2000 random 18bp primer adapters and test in combination with first motif
tf.df$primer1_seq <- "CGGAGCGAACCGAGTTAG"
```


### Include 3' primer sequence from previous library
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
tf.df$primer2_seq <- "CATCGTCGCATCCAAGAG"
```




### Generate random spacings between TF motifs - screen those for TF binding
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## Generate random spacings
## Select top 9 backgrounds for 5 bp spacings (3 backgrounds * 3 spacings per background)

# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif <- tf.df %>% dplyr::select(TF, motif1, space1, motif2) %>% unique()
iteration <- 1:2000
motif <- merge(motif, iteration, all=T)

# Generate 2000 random spacings between TF motifs (that's actually above the max with 5bp spacings)
# GC content ~50%
set.seed(9456)
for (i in 1:2000) {
  motif$space1[motif$y ==i] <- sim.DNAseq(5, GCfreq = 0.5)
}

motif_5bp <- motif

# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
motif_5bp$seq.name <- paste(motif_5bp$TF, motif_5bp$y, sep = "_")
motif_5bp$seq.text <- paste(substrRight(motif_5bp$motif1, 3), 
                       motif_5bp$space1, substr(motif_5bp$motif2, 1, 3), sep = "")
motif_5bp <- motif_5bp[!duplicated(motif_5bp$seq.text),]

# Write fasta file to run on FIMO script
motif_5bp_export <- motif_5bp %>% dplyr::select(seq.name, seq.text)
#dat2fasta(motif_5bp_export, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/5bp_spacer.fasta")       
```


### Run FIMO script
```{bash run fimo db2_4, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/5bp_spacer
# query=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/5bp_spacer.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 2 --o $odir $motfn $query
```



### load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. For some analysis, both Nanog and Klf2 libraries were combined.

```{r build tf motif matrices db2: 5bp_spacer, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_5bp_spacer  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/5bp_spacer/fimo.tsv',
                                        db            = 2)
```


### visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a pre-selection of the top 9 spacers first to narrow down the selection
# convert to binary
tib_pwm_5bp_spacer_binary <- tib_pwm_5bp_spacer %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_5bp_spacer_binary_top <- tib_pwm_5bp_spacer_binary

# compute rowsums to get cumulative binding
tib_pwm_5bp_spacer_binary_top$binding <- rowSums(tib_pwm_5bp_spacer_binary_top[,2:ncol(tib_pwm_5bp_spacer_binary_top)])

# select only cumulative binding and id
tib_pwm_5bp_spacer_binary_top <- tib_pwm_5bp_spacer_binary_top %>%
  dplyr::select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_5bp_spacer_binary_top <- tib_pwm_5bp_spacer_binary_top %>%
  mutate(space = gsub(".*_(.*)", "\\1", id)) %>%
  dplyr::select(-id) %>%
  mutate(cum_binding = ave(binding, space, FUN = sum)) %>%
  dplyr::select(-binding) %>%
  unique()

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_5bp_spacer_binary_top$space)
sel_id <- unique(motif_5bp$y)
space_nohit <- sel_id[!sel_id %in% space_id]
ecori_nhei <- c("GAATTC","GCTAGC")
remove_5bp <- motif_5bp[grep(paste(ecori_nhei, collapse = "|"), motif_5bp$seq.text),]
remove_5bp <- unique(remove_5bp$y)
space_nohit <- space_nohit[!space_nohit %in% remove_5bp]
print(paste(length(space_nohit), "of the", length(iteration), "tested sequences have no TF motif"))
```

### Make final selection for 5bp spacers
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Based on the heatmap above the following spacer IDs were chosen: 
spacers_5bp_selected <- unique(motif_5bp$space1[motif_5bp$y %in% space_nohit]) 

# Add to tf.df
for (i in unique(tf.df$background)) {
  tf.df$space1[tf.df$background == i & tf.df$spacing == "5bp"] <- spacers_5bp_selected[i]
}
spacers_5bp_selected <- spacers_5bp_selected[4:9]
for (i in unique(tf.df$background)) {
  tf.df$space2[tf.df$background == i & tf.df$spacing == "5bp"] <- spacers_5bp_selected[i]
}
spacers_5bp_selected <- spacers_5bp_selected[4:6]
for (i in unique(tf.df$background)) {
  tf.df$space3[tf.df$background == i & tf.df$spacing == "5bp"] <- spacers_5bp_selected[i]
}
```





### Do the same for 10bp spacings
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## Generate random spacings
## Select top 9 backgrounds for 5 bp spacings (3 backgrounds * 3 spacings per background)

# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif <- tf.df %>% dplyr::select(TF, motif1, space1, motif2) %>% unique()
iteration <- 1:2000
motif <- merge(motif, iteration, all=T)

# Generate 2000 random spacings between TF motifs
# GC content ~50%
set.seed(4125)
for (i in 1:2000) {
  motif$space1[motif$y ==i] <- sim.DNAseq(10, GCfreq = 0.5)
}

motif_10bp <- motif

# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
motif_10bp$seq.name <- paste(motif_10bp$TF, motif_10bp$y, sep = "_")
motif_10bp$seq.text <- paste(substrRight(motif_10bp$motif1, 4), 
                       motif_10bp$space1, substr(motif_10bp$motif2, 1, 4), sep = "")
motif_10bp <- motif_10bp[!duplicated(motif_10bp$seq.text),]

# Write fasta file to run on FIMO script
motif_10bp_export <- motif_10bp %>% dplyr::select(seq.name, seq.text)
#dat2fasta(motif_10bp_export, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/10bp_spacer.fasta")       
```


### Run FIMO script
```{bash run fimo db2_4, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/10bp_spacer
# query=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/10bp_spacer.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 2 --o $odir $motfn $query 
```



### load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. For some analysis, both Nanog and Klf2 libraries were combined.

```{r build tf motif matrices db2: 5bp_spacer, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_10bp_spacer  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/10bp_spacer/fimo.tsv',
                                        db            = 2)
```


### visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a pre-selection of the top 9 spacers first to narrow down the selection
# convert to binary
tib_pwm_10bp_spacer_binary <- tib_pwm_10bp_spacer %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_10bp_spacer_binary_top <- tib_pwm_10bp_spacer_binary

# compute rowsums to get cumulative binding
tib_pwm_10bp_spacer_binary_top$binding <- rowSums(tib_pwm_10bp_spacer_binary_top[,2:ncol(tib_pwm_10bp_spacer_binary_top)])

# select only cumulative binding and id
tib_pwm_10bp_spacer_binary_top <- tib_pwm_10bp_spacer_binary_top %>%
  dplyr::select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_10bp_spacer_binary_top <- tib_pwm_10bp_spacer_binary_top %>%
  mutate(space = gsub(".*_(.*)", "\\1", id)) %>%
  dplyr::select(-id) %>%
  mutate(cum_binding = ave(binding, space, FUN = sum)) %>%
  dplyr::select(-binding) %>%
  unique()

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_10bp_spacer_binary_top$space)
space_nohit <- motif_10bp$y[!motif_10bp$y %in% space_id]
remove_10bp <- motif_10bp[grep(paste(ecori_nhei, collapse = "|"), motif_10bp$seq.text),]
remove_10bp <- unique(remove_10bp$y)
space_nohit <- space_nohit[!space_nohit %in% remove_10bp]
print(paste(length(space_nohit), "of the", length(iteration), "tested sequences have no TF motif"))

# This revealed the best 0 hits - now add 9 more to complete 9 
tib_pwm_10bp_spacer_binary_top <- tib_pwm_10bp_spacer_binary_top[order(tib_pwm_10bp_spacer_binary_top$cum_binding),]

# Look at the top 12 to see which TF binds to them (as they all have 1 hit for a TF)
low_binding_space <- tib_pwm_10bp_spacer_binary_top$space[1:9]
low_binding_space <- low_binding_space[!low_binding_space %in% remove_10bp]

# Subselect top 12 from original df
low_binding_space2 <- merge(low_binding_space, unique(tf.df$TF))


low_binding_space2$space <- paste(low_binding_space2$y, low_binding_space2$x, sep = "_")

tib_pwm_10bp_spacer_binary_select <- tib_pwm_10bp_spacer_binary[tib_pwm_10bp_spacer_binary$id %in%
                                                                low_binding_space2$space,]



# convert to matrix - leave out id
tib_pwm_10bp_spacer_binaryMatrix <- as.matrix(dplyr::select(tib_pwm_10bp_spacer_binary_select,-id))

# assign ids as rownames of matrix
rownames(tib_pwm_10bp_spacer_binaryMatrix) <- tib_pwm_10bp_spacer_binary_select$id
```

```{r, fig.height=10, fig.width=10, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
#remove columns with only 0s and plot heatmap
heatmaply(tib_pwm_10bp_spacer_binaryMatrix[, colSums(tib_pwm_10bp_spacer_binaryMatrix != 0) > 0])
```
*There's still some TF binding even to the most neutral backgrounds, but I cannot fully prevent this with that many different motifs in the library*


### Make final selection for 10bp spacers
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Based on the heatmap above the following spacer IDs were chosen: 
spacers_10bp_selected <- tib_pwm_10bp_spacer_binary_top$space[1:10]

# Select sequences from original file
spacers_10bp_selected <- unique(motif_10bp$space1[motif_10bp$y %in% spacers_10bp_selected])
spacers_10bp_selected <- spacers_10bp_selected[-grep(paste(ecori_nhei, collapse = "|"), spacers_10bp_selected)]

# Add to tf.df
for (i in unique(tf.df$background)) {
  tf.df$space1[tf.df$background == i & tf.df$spacing == "10bp"] <- spacers_10bp_selected[i]
}
spacers_10bp_selected <- spacers_10bp_selected[4:9]
for (i in unique(tf.df$background)) {
  tf.df$space2[tf.df$background == i & tf.df$spacing == "10bp"] <- spacers_10bp_selected[i]
}
spacers_10bp_selected <- spacers_10bp_selected[4:6]
for (i in unique(tf.df$background)) {
  tf.df$space3[tf.df$background == i & tf.df$spacing == "10bp"] <- spacers_10bp_selected[i]
}
```




### Now we want to find 3 optimal spacings for in between the last TF motif and the core promoter - 10bp distance
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif_promoter <- tf.df %>% 
  dplyr::select(TF, motif, promoter_sequence) %>% unique()
motif_promoter$dist1 <- ""
iteration <- 1:1000
motif_promoter <- merge(motif_promoter, iteration, all=T)

# Generate 1000 random spacings between last TF motif and core promoter
# GC content ~50%
set.seed(4125)
for (i in 1:1000) {
  motif_promoter$dist1[motif_promoter$y ==i] <- sim.DNAseq(10, GCfreq = 0.5)
}

motif_promoter_space <- motif_promoter
motif_promoter_space$seq.name <- paste(motif_promoter_space$TF, motif_promoter_space$y, sep = "_")


# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
motif_promoter_space$seq.text <- paste(substrRight(motif_promoter_space$motif, 4), 
                       motif_promoter_space$dist1, 
                       substr(motif_promoter_space$promoter_sequence, 1, 4), sep = "")
motif_promoter_space <- motif_promoter_space[!duplicated(motif_promoter_space$seq.text),]

# Write fasta file to run on FIMO script
motif_promoter_space_export <- motif_promoter_space
motif_promoter_space_export <- motif_promoter_space_export %>% dplyr::select(seq.name, seq.text)
#dat2fasta(motif_promoter_space_export, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_1.fasta")     
```


 
### Run FIMO script again 
```{bash run fimo db2_6, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_1
# query=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_1.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 2 --o $odir $motfn $query 
```


### load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. For some analysis, both Nanog and Klf2 libraries were combined.

```{r build tf motif matrices db2: promoter_spacer, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_promoter_spacer  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_1/fimo.tsv',
                                        db            = 2)
```


### visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a pre-selection of the top 9 spacers first to narrow down the selection
# convert to binary
tib_pwm_promoter_spacer_binary <- tib_pwm_promoter_spacer %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary

# compute rowsums to get cumulative binding
tib_pwm_promoter_spacer_binary_top$binding <- rowSums(tib_pwm_promoter_spacer_binary_top[,2:ncol(tib_pwm_promoter_spacer_binary_top)])

# select only cumulative binding and id
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary_top %>%
  dplyr::select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary_top %>%
  mutate(space = gsub(".*_(.*)", "\\1", id)) %>%
  dplyr::select(-id) %>%
  mutate(cum_binding = ave(binding, space, FUN = sum)) %>%
  dplyr::select(-binding) %>%
  unique()


# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_promoter_spacer_binary_top$space)
space_nohit <- unique(motif_promoter_space$y[!motif_promoter_space$y %in% space_id])
remove_10bp <- motif_promoter_space[grep(paste(ecori_nhei, collapse = "|"), motif_promoter_space$seq.text),]
remove_10bp <- unique(remove_10bp$y)
space_nohit <- space_nohit[!space_nohit %in% remove_10bp]
print(paste(length(space_nohit), "of the", length(iteration), "tested sequences have no TF motif"))
```


### Make final selection for promoter spacers
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Based on the heatmap above the following spacer ID was chosen
spacers_selected_promoter_1 <- space_nohit[1:3]

# Select sequences from original file
spacers_selected_promoter_1 <- unique(motif_promoter_space[motif_promoter_space$y %in% spacers_selected_promoter_1,4])
spacers_selected_promoter_1 <- subset(spacers_selected_promoter_1, !(spacers_selected_promoter_1 %in% ecori_nhei))

# Add to tf.df
for (i in unique(tf.df$background)) {
  tf.df$distance_seq[tf.df$background == i & tf.df$distance == "10bp"] <- spacers_selected_promoter_1[i]
}
```






### Do the same for 21 bp spacing
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Subselect one spacing and neighboring TF motifs, make rows for random spacings that will be created
motif_promoter <- tf.df %>% 
  dplyr::select(TF, motif, promoter_sequence) %>% unique()
motif_promoter$dist1 <- ""
iteration <- 1:1000
motif_promoter <- merge(motif_promoter, iteration, all=T)

# Generate 1000 random spacings between last TF motif and core promoter
# GC content ~50%
set.seed(434853)
for (i in 1:1000) {
  motif_promoter$dist1[motif_promoter$y ==i] <- sim.DNAseq(21, GCfreq = 0.5)
}

motif_promoter_space_2 <- motif_promoter
motif_promoter_space_2$seq.name <- paste(motif_promoter_space_2$TF, motif_promoter_space_2$y, sep = "_")


# Assemble sequence to test: 4 rim bases of the TF motifs and the spacer sequence
motif_promoter_space_2$seq.text <- paste(substrRight(motif_promoter_space_2$motif, 4), 
                       motif_promoter_space_2$dist1, 
                       substr(motif_promoter_space_2$promoter_sequence, 1, 4), sep = "")
motif_promoter_space_2 <- motif_promoter_space_2[!duplicated(motif_promoter_space_2$seq.text),]

# Write fasta file to run on FIMO script
motif_promoter_space_2_export <- motif_promoter_space_2
motif_promoter_space_2_export <- motif_promoter_space_2_export %>% dplyr::select(seq.name, seq.text)
#dat2fasta(motif_promoter_space_2_export, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_2.fasta")     
```


 
### Run FIMO script again 
```{bash run fimo db2_6, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_2
# query=/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_2.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 2 --o $odir $motfn $query 
```


### load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. For some analysis, both Nanog and Klf2 libraries were combined.

```{r build tf motif matrices db2: promoter_spacer, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_promoter_spacer  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/promoter_spacer_2/fimo.tsv',
                                        db            = 2)
```


### visualize fimo results
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
## We make a pre-selection of the top 9 spacers first to narrow down the selection
# convert to binary
tib_pwm_promoter_spacer_binary <- tib_pwm_promoter_spacer %>% mutate_if(is.numeric, function(x) ifelse((x==0 | is.na(x)),0,1)) 
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary

# compute rowsums to get cumulative binding
tib_pwm_promoter_spacer_binary_top$binding <- rowSums(tib_pwm_promoter_spacer_binary_top[,2:ncol(tib_pwm_promoter_spacer_binary_top)])

# select only cumulative binding and id
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary_top %>%
  dplyr::select(id,binding)

# make third column wiht only the space_id - then sum up the binding scores per space_id
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary_top %>%
  mutate(space = gsub(".*_(.*)", "\\1", id)) %>%
  dplyr::select(-id) %>%
  mutate(cum_binding = ave(binding, space, FUN = sum)) %>%
  dplyr::select(-binding) %>%
  unique()

# Identify spacers that were exlcuded from fimo script (due to 0 hits)
space_id <- unique(tib_pwm_promoter_spacer_binary_top$space)
space_nohit <- unique(motif_promoter_space_2$y[!motif_promoter_space_2$y %in% space_id])
remove_promoter <- motif_promoter_space_2[grep(paste(ecori_nhei, collapse = "|"), motif_promoter_space_2$seq.text),]
remove_promoter <- unique(remove_promoter$y)
space_nohit <- space_nohit[!space_nohit %in% remove_promoter]
print(paste(length(space_nohit), "of the", length(iteration), "tested sequences have no TF motif"))

# This revealed the best 0 hits - now find 9 more
tib_pwm_promoter_spacer_binary_top <- tib_pwm_promoter_spacer_binary_top[order(tib_pwm_promoter_spacer_binary_top$cum_binding),]

# Look at the top 12 to see which TF binds to them (as they all have 1 hit for a TF)
low_binding_space <- tib_pwm_promoter_spacer_binary_top$space[1:5]
low_binding_space <- low_binding_space[!low_binding_space %in% remove_10bp]

# Subselect top 12 from original df
low_binding_space2 <- merge(low_binding_space, unique(tf.df$TF))


low_binding_space2$space <- paste(low_binding_space2$y, low_binding_space2$x, sep = "_")

tib_pwm_promoter_spacer_binary_select <- tib_pwm_promoter_spacer_binary[tib_pwm_promoter_spacer_binary$id %in%
                                                                low_binding_space2$space,]



# convert to matrix - leave out id
tib_pwm_promoter_spacer_binaryMatrix <- as.matrix(dplyr::select(tib_pwm_promoter_spacer_binary_select,-id))

# assign ids as rownames of matrix
rownames(tib_pwm_promoter_spacer_binaryMatrix) <- tib_pwm_promoter_spacer_binary_select$id
```

### Visualize results
```{r, fig.height=10, fig.width=10, out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
#remove columns with only 0s and plot heatmap
heatmaply(tib_pwm_promoter_spacer_binaryMatrix[, colSums(tib_pwm_promoter_spacer_binaryMatrix != 0) > 0])
```

### Make final selection for 10bp spacers
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Based on the heatmap above the following spacer IDs were chosen: 
promoters_selected <- tib_pwm_promoter_spacer_binary_top$space[3:5]

# Select sequences from original file
promoters_selected <- motif_promoter_space_2$dist1[motif_promoter_space_2$y %in% promoters_selected] %>% unique()
promoters_selected <- subset(promoters_selected, !(promoters_selected %in% ecori_nhei))

# Add to tf.df
for (i in unique(tf.df$background)) {
  tf.df$distance_seq[tf.df$background == i & tf.df$distance == "21bp"] <- promoters_selected[i]
}
```



### Include positive control (chunk of the hPGK promoter)
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
# Import sequence from previous library
pgk <- read.csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/mt20200416_pgk.csv")
colnames(pgk) <- colnames(tf.df)
tf.df <- rbind(tf.df, pgk)
```


### Include all previously published reporters for the selected TFs (from which I found sequences) - I also included some other reporter sequences for non-selected TFs
```{r out.width= "100%", fig.align= "center", echo=FALSE, warning= FALSE}
published_reporters <- read.csv2("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/lambert_2018//mt20210111_published_reporter_sequences.csv")
published_reporters_long <- published_reporters[grep("long", published_reporters$TF),]
published_reporters <- published_reporters[-grep("long", published_reporters$TF),]
tf.df.pub <- tf.df[tf.df$TF == "AR" & tf.df$spacing == "5bp" & tf.df$background == "3",] %>%
  mutate(TF = "",
         spacing = "",
         background = "",
         motif = "",
         motif1 = "",
         space1 = "",
         motif2 = "",
         space2 = "",
         motif3 = "",
         space3 = "",
         motif4 = "")
tf.df.pub <- merge(tf.df.pub, published_reporters$TF) %>%
  mutate(TF = y) %>%
  dplyr::select(-y) 
tf.df.pub <- merge(tf.df.pub, published_reporters) %>%
  mutate(motif2 = sequence) %>%
  dplyr::select(-sequence) 

tf.df.pub_long <- tf.df[tf.df$TF == "AR" & tf.df$spacing == "5bp" & tf.df$background == "3" & tf.df$distance == "10bp",] %>%
  mutate(TF = "",
         spacing = "",
         background = "",
         motif = "",
         motif1 = "",
         space1 = "",
         motif2 = "",
         space2 = "",
         motif3 = "",
         space3 = "",
         motif4 = "",
         distance_seq = "")
tf.df.pub_long <- merge(tf.df.pub_long, published_reporters_long$TF) %>%
  mutate(TF = y) %>%
  dplyr::select(-y) 
tf.df.pub_long <- merge(tf.df.pub_long, published_reporters_long) %>%
  mutate(motif2 = sequence) %>%
  dplyr::select(-sequence) 

# Include background sequence in front of RE sequence to have similar oligo lengths (to prevent PCR biases)
tf.df.pub$nchar_add <- 208 - nchar(paste(tf.df.pub$primer1_seq, tf.df.pub$motif2, tf.df.pub$distance_seq, 
                                         tf.df.pub$promoter_sequence, tf.df.pub$S1_primer, tf.df.pub$primer2_seq, sep = ""))
tf.df.pub$nchar_add[tf.df.pub$nchar_add < 0] <- 0
tf.df.pub$space_add <- "GCTAACTTACTAGTGACCGCACTGTAGGTAGGTCTTCATGTATAACCCAGCCCAACCATTGGGTTCCGTCCTGTACAAAGGCGGTTCCATAAGCAGCCTGTGCGAAGTGGAGTACCAATA" # inactive spacer from pMT06
tf.df.pub$space1 <- substr(tf.df.pub$space_add, 1, tf.df.pub$nchar_add)
tf.df.pub <- tf.df.pub %>%
  dplyr::select(-nchar_add, -space_add)

tf.df <- rbind(tf.df, tf.df.pub, tf.df.pub_long)
```






### Include from each TF from pMT02 the 2 most robust reporters (in case I want to probe this library alone - this can be handy to have more TF reporter data)
```{r out.width= "100%", fig.align= "center", echo=FALSE}
pMT02_reporter <- read.csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/gcf5927_stimulation-1/results/mt20201209_reporter_activity_filt.csv") %>%
  dplyr::filter(neg_ctrls == "No",
                hPGK == "No",
                native_enhancer == "No",
                rand_promoter == "No",
                condition == "2i_pos_LIF",
                promoter != "hBGm") %>%
  dplyr::select(TF, reporter_id, reporter_activity) %>%
  unique()

# Select top 2 reporters for each TF
pMT02_reporter <- pMT02_reporter %>%
  dplyr::arrange(desc(reporter_activity)) %>%
  dplyr::group_by(TF) %>%
  dplyr::slice(1:2)

# Also include negative controls
pMT02_reporter_neg <- pMT02_reporter %>%
  mutate(reporter_id = gsub("^([^_]+)", "_neg", reporter_id),
         reporter_id = paste(TF, reporter_id, sep = ""))
pMT02_reporter <- rbind(pMT02_reporter, pMT02_reporter_neg)

# Extract sequences
pMT02_reporter_seq <- read.csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/mt20210111_tf-array.csv") %>%
  mutate(reporter_id = paste(TF, Spacing, Distance, Promoter, Background, sep = "_"))
pMT02_reporter_seq <- pMT02_reporter_seq[pMT02_reporter_seq$reporter_id %in% pMT02_reporter$reporter_id,] %>%
  dplyr::select(-reporter_id) %>%
  filter(Barcode <= 5)
colnames(pMT02_reporter_seq) <- colnames(tf.df)
pMT02_reporter_seq$TF <- str_to_upper(pMT02_reporter_seq$TF)
pMT02_reporter_seq$TF <- gsub("NEG", "neg", pMT02_reporter_seq$TF)
pMT02_reporter_seq$TF <- gsub("^", "pMT02-", pMT02_reporter_seq$TF)

tf.df <- rbind(tf.df, pMT02_reporter_seq)
```







## Add barcodes
```{r out.width= "100%", fig.align= "center", echo=FALSE}
## Randomizing barcodes
barcode_list <- read.csv("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/parameter_files/barc_selected.csv") %>%
  dplyr::select(barcode = x)
barcode_list <- barcode_list[-grep("GCTAG", barcode_list$barcode),]
set.seed(123)
barcode_list <- sample(barcode_list)
tf.df$barcode <- barcode_list[1:nrow(tf.df)]

# Check if there are any duplicate barcodes
paste("duplicate barcodes: ", nrow(tf.df[duplicated(tf.df$barcode),]), sep ="")

# Save for later export
tf.df.long.export <- tf.df
```




# Check-up & Visualizations
```{r out.width= "100%", fig.align= "center", echo=FALSE}
# Length distribution
# Save intermediate df for later purpose
tf.array <- tf.df
tf.df[is.na(tf.df)] <- ""
tf.df$seq.text <- paste(tf.df$primer1_seq, tf.df$motif1, tf.df$space1, tf.df$motif2,
                    tf.df$space2, tf.df$motif3, tf.df$space3, tf.df$motif4, 
                    tf.df$distance_seq, tf.df$promoter_sequence, tf.df$S1_primer,
                    tf.df$barcode, tf.df$primer2_seq, sep = "")
print(nrow(tf.df[grep(paste(ecori_nhei, collapse = "|"),tf.df$seq.text),]))


tf.df$nchar <- nchar(tf.df$seq.text)

ggplot(tf.df, aes(x = nchar)) +
   geom_histogram(aes(y=..count..), colour="black", fill="#E69F00", binwidth = 5)+ 
  xlab("Length Oligo (binwidth = 5)") + ylab("Frequency") +
    labs(title = "Overview of oligo lengths in pool", 
         subtitle = paste("Total oligos =", nrow(tf.df), "|",
                          "max oligo length =", max(nchar(tf.df$seq.text)), "|",
                          "min oligo length = ", min(nchar(tf.df$seq.text)), "|",
                          "mean oligo length = ", round(mean(nchar(tf.df$seq.text))))) +
  theme_classic()
```



## Exporting potential data. 
```{r}
## Exporting
tf.df$seq.name <- paste(tf.df$TF, "_s-", tf.df$spacing, "_d-", tf.df$distance, "_bg-", tf.df$background,
                        "_", tf.df$promoter, "_bc-", tf.df$n_barcode, sep = "")
tf.df.export <- tf.df %>% dplyr::select(seq.name, seq.text) %>% unique() %>%
  mutate(seq.name = gsub("s-NA_", "", seq.name),
         seq.name = gsub("d-NA_", "", seq.name),
         seq.name = gsub("bg-NA_", "", seq.name),
         seq.name = gsub("bg-_", "", seq.name),
         seq.name = gsub("s-_", "", seq.name))

paste("duplicate sequence names: ", nrow(tf.df.export[duplicated(tf.df.export$seq.name),]), sep ="")
paste("duplicate sequences: ", nrow(tf.df.export[duplicated(tf.df.export$seq.text),]), sep ="")


# Compute GC-content of complete sequences
tf_df_fasta <- tf.df.export
dat2fasta(tf_df_fasta, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/gen-2_tf_df_fasta.fasta") 
tf_df_fasta <- seqinr::read.fasta("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/output/gen-2_tf_df_fasta.fasta")
gc <- compute_GC(tf_df_fasta)

# Plot gc distribution
density <- density(gc$GC.content)

plot_ly(x = ~density$x, y = ~density$y, type = 'scatter', mode = 'lines', fill = 'tozeroy') %>% 
  layout(xaxis = list(title = 'GC content'),
         yaxis = list(title = 'Density'))

# Write csv file
filename <- SetFileName("_oligo_pool_gen2", "mt")
setwd("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/")
write.csv(tf.df.export, file = paste(filename,".csv", sep = ""), row.names = F)

# Write fasta file
setwd("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/")
dat2fasta(tf.df.export, outfile = paste(filename,".fasta", sep = ""))  

```




## Addition: Scan all the reporters again (especially the negative controls) to ensure that only the desired TFs are binding
```{r}
# Select sequence in front of core promoter
tf.df.check <- ReadFasta("/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/mt20210114_oligo_pool_gen2.fasta") %>%
  mutate(name = gsub("(.*bg-[1-3]{1})_.*", "\\1", name)) %>%
  filter(str_detect(name, "TF-seq", negate = T), 
         str_detect(name, "romanov", negate = T),
         str_detect(name, "promega", negate = T),
         str_detect(name, "TF-seq", negate = T),
         str_detect(name, "hPGK", negate = T))

tf.df.check <- tf.df.check %>%
  mutate(sequence2 = gsub("CGGAGCGAACCGAGTTAG", "", sequence),
         sequence3 = gsub("TAGAGGGTATATAATGGAAGCTCGACTTCCAG.*", "", sequence2),
         sequence4 = gsub("GGCGTTTACTATGGGAGGTCTATATAAGCAGAGCTCGTTTAGTGAACCGTCAGATC.*", "", sequence3),
         sequence5 = gsub("GGTTAGCGATCCAATTCAGCTAGATTTTAAGC.*", "", sequence4)) %>%
  dplyr::select("seq.name" = name, "seq.text" = sequence5) %>%
  unique()


dat2fasta(tf.df.check, outfile = "/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/tf_check.fasta")   
```

## Run FIMO script again 
```{bash run fimo db2_9, eval = FALSE}
# motfn=/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/20170320_pwms_selected.meme
# odir=//DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/reporter_check
# query=/DATA/usr/m.trauernicht/projects/SuRE-TF/data/library_design/gen-2/fimo/tf_check.fasta

# nice -n 19 fimo --no-qvalue --thresh 1e-4 --verbosity 1 --o $odir $motfn $query 
```



## load fimo results
We built a TF motif matrix using -log10 transformed FIMO scores. We used this feature encoding throughout the rest of this analysis, unless otherwise stated. 

```{r build tf motif matrices db2: tf_check, out.width= "100%", fig.align= "center", echo=FALSE}
# load motif Metadata --> PWM feature matrix
tib_pwm_tf_check  <- get_pwm_feature_matrix(motif_meta_fn = '/home/m.trauernicht/mydata/data/TFDB/natoli_update_2017/fc181127_curated_metadata_no_composite_filt.csv', 
                                        fimo_fn       = '/home/m.trauernicht/mydata/projects/SuRE-TF/data/library_design/gen-2/fimo/reporter_check/fimo.tsv',
                                        db            = 2)
```


```{r, fig.height=4, fig.width=4, out.width= "100%", fig.align= "center", echo=FALSE, eval=FALSE}
# Generate heatmaps in a loop for each TF
# Select only hits
tib_pwm_tf_check$TF <- gsub("[.*.|_].*","\\1",tib_pwm_tf_check$id)

tib_pwm_tf_check_2 <- tib_pwm_tf_check %>% 
  remove_rownames %>% column_to_rownames(var="id")

# Create breaks for heatmap (to make legend between heatmaps comparable)
myBreaks1 <- seq(0,8,0.08)

 # Prepare annotation for the heatmap rows
tib_pwm_tf_check_3 <- tib_pwm_tf_check_2
tib_pwm_tf_check_3$neg <- "disrupted"
tib_pwm_tf_check_3$neg[-grep("neg", rownames(tib_pwm_tf_check_3))] <- "high-affinity"
neg <- tib_pwm_tf_check_3[,which(colnames(tib_pwm_tf_check_3) == "neg"),drop=FALSE]
colors <- list(
   neg = c("high-affinity"= "#B3E2CD", "disrupted"="#FDCDAC"))


# Create heatmaps for each TF
tib_pwm_tf_check_2 <- tib_pwm_tf_check_2 %>% filter(str_detect(TF, "Random", negate = TRUE))
for (i in unique(tib_pwm_tf_check_2$TF)) {
  data <- tib_pwm_tf_check_2[tib_pwm_tf_check_2$TF == i,]
  data <- data[,colSums(data != 0) > 0]
p <- pheatmap(as.matrix(data %>% dplyr::select(-TF)), 
              main = paste(i),
              border_color = "#000000",
              annotation_row = neg,
              annotation_colors = colors,
              breaks = myBreaks1)
print(p)
}
```




# Session Info
```{r}
paste("Run time: ",format(Sys.time()-StartTime))
getwd()
date()
sessionInfo()
```

